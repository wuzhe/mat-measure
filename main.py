#!/usr/bin/env python

from __future__ import with_statement
import sys
import Queue
import math
import cairo
from delaunay.core import Triangulation
from vecangle import vecangle
from xpermutations import xuniqueCombinations
from convexhull import convexHull
from pprint import pprint

INTERIOR = False
EXTERIOR = True
WIDTH, HEIGHT = 512, 512 # output image dimension


def recur_map(fun, data):
    if not data:
        return []
    if hasattr(data[0], "__iter__"):
        return tuple([recur_map(fun, elem) for elem in data])
    else:
        return fun(data)

def poff_reader(filename):
    """Read poff files generated by Mesecina software."""
    points = []
    first_line = True
    with open(filename) as f:
        for line in f:
            if first_line:
                number_points, o_x, o_y = map(int, line.split()[1:])
                assert (o_x, o_y) == (0, 0)
                assert number_points > 0
                first_line = False
            else:
                points.append(tuple(map(float, line.split())))
    assert len(points) == number_points
    return points


def get_circumcenter(v):
    """Returns the coordinate of circumcenter of a triangle

    Formula from
    http://en.wikipedia.org/wiki/Circumcenter#Coordinates_of_circumcenter
    """
    b = (v[1][0] - v[0][0], v[1][1] - v[0][1])
    c = (v[2][0] - v[0][0], v[2][1] - v[0][1])
    d = 2*(b[0]*c[1] - b[1]*c[0])
    center = ((c[1]*(b[0]**2 + b[1]**2) - b[1]*(c[0]**2 + c[1]**2)) / d,
              (b[0]*(c[0]**2 + c[1]**2) - c[0]*(b[0]**2 + b[1]**2)) / d) + v[0]
    return (center[0] + v[0][0], center[1] + v[0][1])

def get_neighbours(triangles):
    """Calculate neighbours of each triangle"""
    neighbours = {}
    for face in triangles:
        neighbours[face] = filter(lambda x: len(set(x) & set(face)) == 2,
                                  triangles)
    return neighbours


def idx_to_real(triangles_idx, points):
    return map(lambda x: tuple(map(points.__getitem__, x)), triangles_idx)


def length(e):
    """Calculate length of a edge"""
    return math.sqrt((e[1][0] - e[0][0])**2 + (e[1][1] - e[0][1])**2)


def get_edges(points):
    edges = set([])
    previous_point = None
    for point in points:
        if previous_point:
            edges.add(tuple(sorted((previous_point, point))))
        else:
            first_point = point
        previous_point = point
    edges.add(tuple(sorted((point, first_point))))
    return edges


def get_any_part_area(edge, i_neighbours, areas):
    init_triangles = filter(lambda x: (edge[0] in x) and (edge[1] in x),
                            i_neighbours.keys())
    start_t = init_triangles[0]
    other_t = init_triangles[1:]
    q = Queue.Queue()
    q.put(start_t)
    visited_t = set([])
    while not q.empty():
        t = q.get()
        visited_t.add(t)
        for new_t in i_neighbours[t]:
            if (new_t in other_t) or (new_t in visited_t):
                continue
            q.put(new_t)
    return sum([areas[x] for x in visited_t])


def get_voronoi_and_salience(poff_filename):
    points = poff_reader(poff_filename)

    # Convex hull
    convex_hull = convexHull(points)
    convex_hull_idx = map(lambda p: points.index(p), convex_hull)
    convex_hull_edges = get_edges(convex_hull_idx)

    # Get boundaries edges
    points_idx = range(0, len(points))
    boundary_edges = get_edges(points_idx)

    # Add one dimension
    o_points = map(lambda x: x + (0,), points)

    # Add a virtual infinite vertex
    #inf_vertex = (0, 0, float('inf'))
    inf_vertex = (0, 0, 9999999)
    points = o_points + [inf_vertex]
    inf_idx = points.index(inf_vertex)

    # Get triangles (in 3D)
    t_obj = Triangulation(points)
    tetraherons = t_obj.get_elements_indices()

    triangles = filter(lambda x: inf_idx not in x,
                       set([tuple(sorted(i)) for t in tetraherons
                            for i in xuniqueCombinations(t, 3)]))

    # Calculate neighbours table
    neighbours = get_neighbours(triangles)

    # Classify all infinite Delaunay faces as EXTERIOR and push them
    # to a queue
    side_table = {}
    q = Queue.Queue()
    for face in triangles:
        edges = set([tuple(sorted(e)) for e in xuniqueCombinations(face, 2)])
        if edges & (convex_hull_edges - boundary_edges):
            side_table[face] = EXTERIOR
            q.put(face)
            continue
        if edges & (boundary_edges & convex_hull_edges):
            side_table[face] = INTERIOR
            q.put(face)
            continue
    # Collect all EXTERIOR triangles
    o_triangles_idx = filter(lambda x: side_table[x] is EXTERIOR, side_table.keys())
    o_triangles = idx_to_real(o_triangles_idx, o_points)

    # Mark every triangle as EXTERIOR or INTERIOR
    while not q.empty():
        face = q.get()
        for nface in neighbours[face]:
            if nface not in side_table:
                nedge = tuple(sorted(list(set(nface) & set(face))))
                assert len(nedge) == 2
                if nedge in boundary_edges:
                    side_table[nface] = not side_table[face]
                else:
                    side_table[nface] = side_table[face]
                q.put(nface)

    # Collect all INTERIOR triangles
    i_triangles_idx = filter(lambda x: side_table[x] is INTERIOR, triangles)
    i_triangles = idx_to_real(i_triangles_idx, o_points)

    # Filter neighbours dictionary to only INTERIOR triangles
    i_neighbours = {}
    for k, d in neighbours.items():
        if side_table[k] is INTERIOR:
            i_neighbours[k] = filter(lambda x: side_table[x] is INTERIOR, d)

    # Calculate areas and circumenteres of triangles
    areas = {}
    circumcenters = {}
    for t_idx, t in zip(i_triangles_idx, i_triangles):
        areas[t_idx] = abs((t[2][0] - t[0][0]) * (t[1][1] - t[0][1]) - \
                           (t[1][0] - t[0][0]) * (t[2][1] - t[0][1])) / 2
        circumcenters[t_idx] = get_circumcenter(t)

    # find triangles that have two edge on the boundary
    boundary_triangles_idx = set([])
    for t in i_triangles_idx:
        edges = set([tuple(sorted(e)) for e in xuniqueCombinations(t, 2)])
        if len(edges & boundary_edges) == 2:
            boundary_triangles_idx.add(t)

    # traverse all triangles, and calculate the salience value
    voronoi_edges = []
    r = {}
    k = {}
    sum_area = sum(areas.values())
    visited_t = set([])
    for start_t in boundary_triangles_idx:
        q = Queue.Queue()
        q.put(start_t)
        while not q.empty():
            t = q.get()
            visited_t.add(t)
            for new_t in i_neighbours[t]:
                if new_t in visited_t:
                    continue
                nedge = tuple(sorted(list(set(new_t) & set(t))))
                assert len(nedge) == 2
                area_1 = get_any_part_area(nedge, i_neighbours, areas)
                area_2 = sum_area - area_1
                v_edge = tuple(sorted([circumcenters[t], circumcenters[new_t]]))
                if v_edge[0] == v_edge[1]:
                    q.put(new_t)
                    continue
                if v_edge not in voronoi_edges:
                    voronoi_edges.append(v_edge)
                r[v_edge] = min(area_1, area_2) / max(area_1, area_2)
                k[v_edge] = min(area_1, area_2) / length(v_edge)
                q.put(new_t)
        break

    # Do something with r, k and voronoi_edges
    return o_points, voronoi_edges, r, k, i_triangles
    #return o_points, voronoi_edges, r, k, idx_to_real(triangles, o_points)


def rescale_points(o, v, r, k, i):
    x_list = map(lambda x: x[0], o)
    y_list = map(lambda x: x[1], o)

    x_min, x_max = min(x_list), max(x_list)
    y_min, y_max = min(y_list), max(y_list)

    x_diff = x_max - x_min
    y_diff = y_max - y_min

    rescale = lambda x: ((x[0] - x_min) / x_diff,
                         1.0 - (x[1] - y_min) / y_diff)

    o = map(rescale, o)
    v = recur_map(rescale, v)

    i = recur_map(rescale, i)

    val_rescale = lambda x, v: (x - min(v.values())) / \
                  (max(v.values()) - min(v.values()))

    new_r = {}
    for t, val in r.items():
        new_r[tuple(map(rescale, t))] = val_rescale(val, r)

    new_k = {}
    for t, val in k.items():
        new_k[tuple(map(rescale, t))] = val_rescale(val, k)

    return o, v, new_r, new_k, i


def draw_consecutive_lines(ctx, points):
    previous_point = None
    for point in points:
        if previous_point:
            ctx.line_to(*point)
        else:
            ctx.move_to(*point)
            first_point = point
        previous_point = point
    ctx.line_to(*first_point)


def draw_edges(ctx, edges, r=None):
    for e in edges:
        if r:
            c = r[e]
            ctx.set_line_width(c/10)
        ctx.move_to(*e[0])
        ctx.line_to(*e[1])
        if r:
            ctx.stroke()


def draw(o, v, r, k, i, filename):
    o, v, r, k, i = rescale_points(o, v, r, k, i)

    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, WIDTH, HEIGHT)
    ctx = cairo.Context(surface)
    ctx.scale(WIDTH/1.0, HEIGHT/1.0) # Normalizing the canvas

    # Draw shape boundary
    ctx.set_source_rgb(0.2, 0.2, 0.6)
    ctx.set_line_width(0.005)
    draw_consecutive_lines(ctx, o)
    ctx.stroke()

    # Draw internal delaunay triangulation
    ctx.set_source_rgba(0.3, 0.2, 0.5, 0.6)
    ctx.set_line_width(0.002)
    edges = set([])
    for t in i:
        for edge in xuniqueCombinations(t, 2):
            edges.add(tuple(edge))
    draw_edges(ctx, edges)
    ctx.stroke()

    # Draw voronoi skeleton
    ctx.set_source_rgba(0.5, 0.2, 0.2, 0.8)
    #draw_edges(ctx, v, r)
    draw_edges(ctx, v, k)

    surface.write_to_png(filename)


def main(input_file, output_file):
    o, v, r, k, i = get_voronoi_and_salience(input_file)
    draw(o, v, r, k, i, output_file)

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print "please specify input and output file path"
        sys.exit()
    main(sys.argv[1], sys.argv[2])

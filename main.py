#!/usr/bin/env python

from __future__ import with_statement
import sys
import Queue
import math
from delaunay.core import Triangulation
from vecangle import vecangle
from xpermutations import xuniqueCombinations
from numpy import array


INTERIOR = False
EXTERIOR = True


def poff_reader(filename):
    """Read poff files generated by Mesecina software."""
    points = []
    with open(filename) as f:
        first_line = True
        for line in f:
            if first_line:
                t, number_points, o_x, o_y = line.split()
                assert t == 'POFF'
                assert (o_x, o_y) == (0, 0)
                assert number_points > 0
                first_line == False
            else:
                points.append(map(float, line.split()))
    assert len(points) == number_points
    return points


def get_circumcenter(v):
    """Returns the coordinate of circumcenter of a triangle

    Formula from
    http://en.wikipedia.org/wiki/Circumcenter#Coordinates_of_circumcenter
    """
    b = v[1] - v[0]
    c = v[2] - v[0]
    d = 2*(b[0]*c[1] - b[1]*c[0])
    center = ((c[1](b[0]**2 + b[1]**2) - b[1](c[0]**2 + c[1]**2)) / d,
              (b[0](c[0]**2 + c[1]**2) - c[0](b[0]**2 + b[1]**2)) / d) + v[0]


def get_neighbors(v_neighbours, triangles, points):
    """Calculate neighbours of each triangle and neighbouring edges"""

    # Convert neighbours of coordinates to those of indices
    neighbours_idx = {}
    for v, n_v in v_neighbours:
        neighbours_idx[points.index(v)] = map(lambda x: points.index(x), n_v)

    neighbours = {}
    for face in triangles:
        edges = xuniqueCombinations(face, 2)
        neighbours[face] = [(edge, sorted((edge + (v,))))
                             for v in set(neighbours_idx[edge[0]]) & set(neighbours_idx[edge[1]]) - set(face)
                             for edge in edges]
    return neighbours


def length(e):
    """Calculate length of a edge"""
    return math.sqrt((e[1][0] - e[0][0])**2 + (e[1][1] - e[0][1])**2)


def main():
    # Read poff file
    poff_filename = sys.argv[1]
    points = poff_reader(poff_filename)

    # Add one dimension
    o_points = map(lambda x: x + (0, ), points)

    # Add a virtual infinite vertex
    inf_vertex = (0, 0, float('inf'))
    points = o_points + inf_vertex

    # Get triangles (in 3D)
    t_obj = Triangulation(points)
    tetraherons = t_obj.get_elements_indices()
    triangles = set([sorted(xuniqueCombinations(t, 3)) for t in tetraherons])

    # Calculate neighbours table
    v_neighbours = t_obj.get_neighbours()
    neighbours = get_neighbours(v_neighbours, triangles, points)

    # Classify all infinite Delaunay faces as EXTERIOR and push them
    # to a queue
    side_table = {}
    q = Queue.Queue()
    for face in triangles:
        if inf_vertex in face:
            q.put(face)
            side_table[face] = EXTERIOR

    # Mark every triangle as EXTERIOR or INTERIOR
    is_consecutive = lambda edge: abs(edge[0] - edge[1]) in (1, len(o_points)-1)
    while not q.empty():
        face = q.get()
        for nedge, nface in neighbors(face):
            if nface not in side_table:
                if is_consecutive(nedge):
                    side_table[nface] = ~side_table[face]
                else:
                    side_table[nface] = side_table[face]
                q.put(nface)

    # Collect all INTERIOR triangles
    i_triangles_idx = filter(lambda x: side_table[x] is INTERIOR, triangles)
    i_triangles = map(o_points.__getitem__, i_triangles_idx)
    for t in i_triangles:
        for v in t:
            assert v[3] == 0 # ensure all vertexes are on xy plane

    # Filter neighbours dictionary to only INTERIOR triangles
    i_neighbours = {}
    for k, d in neighbours.items():
        if side_table[k] is INTERIOR:
            i_neighbours[k] = filter(lambda x: side_table[x[1]] is INTERIOR, d)

    # Calculate areas and circumenteres of triangles
    areas = {}
    circumcenters = {}
    for t_idx, t in zip(i_triangles_idx, i_triangles):
        areas[t_idx] = abs((t[2][0] - t[0][0]) * (t[1][1] - t[0][1]) - \
                           (t[1][0] - t[0][0]) * (t[2][1] - t[0][1])) / 2
        circumcenters[t_idx] = get_circumcenter(t)

    # find triangles that have two edge on the boundary
    #
    # Three possible cases:
    #   1. x###xxx, vertices in the middle of the sorted points
    #   2. #xxxx##, one vertex at the first, two remaining at the last
    #   3. ##xxxx#, two vertices at the first, one remaining at the last
    #
    boundary_triangles_idx = set([])
    for t in i_triangles_idx:
        if (t[2] - t[1] == t[1] - t[0] == 1) or \
           (t[0] == 0 and t[1] == len(o_points)-2 and t[2] == len(o_points)-1) or \
           (t[0] == 0 and t[1] == 1 and t[2] == len(points) - 1):
            boundary_triangles_idx.add(t)

    # traverse all triangles, and calculate the salience value
    r = {}
    k = {}
    voronoi_edges = set([])
    visited_area = 0
    sum_area = sum(areas.values())
    visited_t = set([])
    visited_area = 0
    for start_t in boundary_triangles_idx:
        q = Queue.Queue()
        q.put(start_t)
        while not q.empty():
            t = q.get()
            visited_t.add(t)
            visited_area += areas[t]
            for d_edge, new_t in i_neighbours[t]:
                if new_t in visited_t:
                    continue
                v_edge = set([circumcenters[t], circumcenters[new_t]])
                voronoi_edges.add(v_edge)
                r[v_edge] = min(visited_area, sum_area-visited_area) / \
                            max(visited_area, sum_area-visited_area)
                k[v_edge] = min(visited_area, sum_area-visited_area) / \
                            length(v_edge)
                q.put(new_t)
        break

    # Do something with r, k and voronoi_edges


if __name__ == '__main__':
    main()
